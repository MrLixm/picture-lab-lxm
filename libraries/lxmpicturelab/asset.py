import dataclasses
import enum
import json
import logging
from pathlib import Path


LOGGER = logging.getLogger(__name__)


class MetadataValidationError(BaseException):
    """
    When an asset metadadata file is invalid.
    """

    pass


class AssetPrimaryColor(enum.Enum):
    """
    Average color observed in an ImageryAsset
    """

    rainbow = "rainbow"
    neutral = "neutral"
    white = "white"
    blue = "blue"
    purple = "purple"
    pink = "pink"
    red = "red"
    orange = "orange"
    yellow = "yellow"
    green = "green"
    brown = "brown"
    dark = "dark"

    def __lt__(self, other):
        color_sorted = [
            self.blue,
            self.purple,
            self.pink,
            self.red,
            self.orange,
            self.yellow,
            self.green,
            self.brown,
            self.dark,
            self.white,
            self.neutral,
            self.rainbow,
        ]
        return color_sorted.index(self) > color_sorted.index(other)


class AssetType(enum.Enum):
    cgi = "cgi"
    """
    computer generated image (image fully generated by a software).
    """

    plate = "plate"
    """
    real world photographic capture
    """


@dataclasses.dataclass
class AssetMetadata:
    """
    Meatadata associated to an ImageryAsset.
    """

    source: str = dataclasses.field(
        metadata={
            "serialized-name": "source",
        },
    )
    authors: list[str] = dataclasses.field(
        metadata={
            "serialized-name": "authors",
        },
    )
    references: list[str] = dataclasses.field(
        metadata={
            "serialized-name": "references",
        },
    )
    capture_gamut: str = dataclasses.field(
        metadata={
            "serialized-name": "capture-gamut",
            "caster-in": str,
        },
    )
    primary_color: AssetPrimaryColor = dataclasses.field(
        metadata={
            "serialized-name": "primary-color",
            "caster-in": AssetPrimaryColor,
            "caster-out": lambda v: v.value,
        },
    )
    type: AssetType = dataclasses.field(
        metadata={
            "serialized-name": "type",
            "caster-in": AssetType,
            "caster-out": lambda v: v.value,
        },
    )
    context: str | None = dataclasses.field(
        default=None,
        metadata={
            "serialized-name": "context",
            "caster-in": str,
        },
    )

    def to_dict(self) -> dict:
        """
        Convert to a json serializable dict.
        """

        def _default_cast(x):
            return x

        as_dict = {}

        for field in dataclasses.fields(self):

            serialized_name = field.metadata["serialized-name"]
            caster = field.metadata.get("caster-out") or _default_cast
            field_value = getattr(self, field.name)

            # check if the field is mandatory and skip if default value
            if (
                field.default is not dataclasses.MISSING
                and field_value == field.default
            ):
                continue

            as_dict[serialized_name] = caster(field_value)

        return as_dict

    def to_json_file(self, file_path: Path, **json_kwargs):
        """
        Serialize to a json file.
        """
        asdict = self.to_dict()
        with file_path.open("w", encoding="utf-8") as file:
            json.dump(asdict, file, **json_kwargs)

    @classmethod
    def from_dict(cls, serialized_dict: dict) -> "AssetMetadata":
        """
        Generate an instance from a json serializable dict.
        """

        def _default_cast(x):
            return x

        kwargs = {}
        for field in dataclasses.fields(cls):
            is_required = (
                field.default is not dataclasses.MISSING
                or field.default_factory is not dataclasses.MISSING
            )
            serialized_name = field.metadata["serialized-name"]
            caster = field.metadata.get("caster-in") or _default_cast

            if is_required:
                if serialized_name not in serialized_dict:
                    raise MetadataValidationError(
                        f"Missing mandatory key '{serialized_name}' in {serialized_dict}"
                    )

                kwargs[field.name] = caster(serialized_dict[serialized_name])

            elif serialized_name in serialized_dict:
                kwargs[field.name] = caster(serialized_dict[serialized_name])

        return cls(**kwargs)

    @classmethod
    def from_json_file(cls, file_path: Path) -> "AssetMetadata":
        """
        Unserialize from a json file.
        """
        with file_path.open("r", encoding="utf-8") as file:
            content = json.load(file)
        return cls.from_dict(serialized_dict=content)


class ImageAsset:
    """
    Represent a virtual test image "asset".

    On the filesystem it built out of 2 files: a side-car json to hold metadata and
    an image file, both with the same path stem.
    Only the json file is mandatory to exists to be a valid asset.

    Args:
        json_path: filesystem path to a json file that may not exist yet.
    """

    image_suffix = ".exr"

    def __init__(self, json_path: Path):
        self.json_path = json_path

    def __repr__(self):
        return f"{self.__class__.__name__}({self.json_path!r})"

    def __str__(self):
        return f"{self.__class__.__name__}<{self.identifier}>"

    @property
    def identifier(self) -> str:
        return self.json_path.stem

    @property
    def metadata(self) -> AssetMetadata:
        return AssetMetadata.from_json_file(self.json_path)

    @property
    def image_path(self) -> Path:
        return self.json_path.with_suffix(self.image_suffix)

    @property
    def is_cgi(self) -> bool:
        return self.metadata.type == AssetType.cgi

    @property
    def is_plate(self) -> bool:
        return self.metadata.type == AssetType.plate

    def delete_files(self):
        """
        Remove all the associated files if they exist on the filesystem.
        """
        for path in [self.json_path, self.image_path]:
            if path and path.exists():
                LOGGER.debug(f"unlink('{path}')")
                path.unlink()

    def with_root_path(self, new_root: Path) -> "ImageAsset":
        """
        Return the same instance but located in a new root directory.

        The new instance may not exist on the filesystem yet.
        """
        new_json_path = new_root / self.json_path.name
        return ImageAsset(new_json_path)
